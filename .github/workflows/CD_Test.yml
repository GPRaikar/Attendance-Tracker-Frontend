name: Deployment

on:
  workflow_dispatch:
    inputs:
      train_branch:
        description: "Select Train Branch"
        required: true
        type: choice
        options:
          - train/2025_11
          - train/2025_10
          - train/2025_09
          - train/2025_08
      build_number:
        description: "Enter Build Number (numbers only)"
        required: true
        type: string
      dev_server:
        description: "Select Feature Server to deploy"
        required: true
        type: choice
        options:
          - f1s2 f2s2-reporting
          - f2s2 f2s2-reporting
          - f3s2 f3s2-reporting
          - f4s2 f4s2-reporting
          - f5s2 f5s2-reporting
          - f6s2 f6s2-reporting
          - f7s2 f7s2-reporting
          - f8s2 f8s2-reporting
          - f9s2 f9s2-reporting
          - f10s2 f10s2-reporting

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate build number is numeric
        run: |
          if ! [[ "${{ github.event.inputs.build_number }}" =~ ^[0-9]+$ ]]; then
            echo "ERROR: Build number must be numeric"
            exit 1
          fi
          echo "Build number is valid"

      - name: Parse and prepare variables
        id: vars
        run: |
          # Convert train branch to URL encoded format
          TRAIN_BRANCH="${{ github.event.inputs.train_branch }}"
          ENCODED_BRANCH="${TRAIN_BRANCH//\//%2F}"
          echo "encoded_branch=$ENCODED_BRANCH" >> $GITHUB_OUTPUT
          echo "Original branch: $TRAIN_BRANCH"
          echo "Encoded branch: $ENCODED_BRANCH"
          
          # Parse dev servers
          DEV_SERVER="${{ github.event.inputs.dev_server }}"
          APP_SERVER=$(echo $DEV_SERVER | awk '{print $1}')
          REPORTING_SERVER=$(echo $DEV_SERVER | awk '{print $2}')
          
          APP_SERVER_FQDN="${APP_SERVER}.ppmpro.team"
          REPORTING_SERVER_FQDN="${REPORTING_SERVER}.ppmpro.team"
          
          echo "app_server=$APP_SERVER_FQDN" >> $GITHUB_OUTPUT
          echo "reporting_server=$REPORTING_SERVER_FQDN" >> $GITHUB_OUTPUT
          
          echo "App Server: $APP_SERVER_FQDN"
          echo "Reporting Server: $REPORTING_SERVER_FQDN"

      - name: Print deployment information
        run: |
          echo "============================================"
          echo "DEPLOYMENT INFORMATION"
          echo "============================================"
          echo "Train Branch: ${{ github.event.inputs.train_branch }}"
          echo "Build Number: ${{ github.event.inputs.build_number }}"
          echo "Encoded Branch: ${{ steps.vars.outputs.encoded_branch }}"
          echo "App Server: ${{ steps.vars.outputs.app_server }}"
          echo "Reporting Server: ${{ steps.vars.outputs.reporting_server }}"
          echo "Working Directory: $(pwd)"
          echo "Triggered by: ${{ github.actor }}"
          echo "============================================"

      - name: Download artifacts from S3
        run: |
          echo "Downloading artifacts from S3..."
          S3_PATH="s3://ppmpro-jenkins-artifacts/Build/${{ steps.vars.outputs.encoded_branch }}/${{ github.event.inputs.build_number }}/artifacts/build/"
          echo "S3 Path: $S3_PATH"
          
          # Download all required .deb files
          aws s3 cp "${S3_PATH}innotas-common.deb" . || { echo "Failed to download innotas-common.deb"; exit 1; }
          aws s3 cp "${S3_PATH}innotas-db.deb" . || { echo "Failed to download innotas-db.deb"; exit 1; }
          aws s3 cp "${S3_PATH}innotas-client.deb" . || { echo "Failed to download innotas-client.deb"; exit 1; }
          aws s3 cp "${S3_PATH}innotas-app.deb" . || { echo "Failed to download innotas-app.deb"; exit 1; }
          aws s3 cp "${S3_PATH}innotas-reporting.deb" . || { echo "Failed to download innotas-reporting.deb"; exit 1; }
          
          echo "All artifacts downloaded successfully"
          ls -lh *.deb

      - name: Deploy to App Server
        run: |
          echo "Deploying to App Server: ${{ steps.vars.outputs.app_server }}"
          
          # Remove old host key
          ssh-keygen -R ${{ steps.vars.outputs.app_server }} || true
          
          # Copy artifacts to app server
          echo "Copying artifacts to app server..."
          scp -i /home/ubuntu/build_cred/build \
              -o StrictHostKeyChecking=no \
              innotas-common.deb innotas-db.deb innotas-client.deb innotas-app.deb \
              build@${{ steps.vars.outputs.app_server }}:/tmp/
          
          if [ $? -ne 0 ]; then
            echo "Failed to copy artifacts to app server"
            exit 1
          fi
          
          # Install packages on app server
          echo "Installing packages on app server..."
          ssh -i /home/ubuntu/build_cred/build \
              -o StrictHostKeyChecking=no \
              -l build \
              ${{ steps.vars.outputs.app_server }} \
              "set -o pipefail; cd /tmp; sudo dpkg -i innotas-common.deb innotas-db.deb innotas-client.deb innotas-app.deb"
          
          if [ $? -eq 0 ]; then
            echo "App server deployment completed successfully"
          else
            echo "App server deployment failed"
            exit 1
          fi

      - name: Deploy to Reporting Server
        run: |
          echo "Deploying to Reporting Server: ${{ steps.vars.outputs.reporting_server }}"
          
          # Remove old host key
          ssh-keygen -R ${{ steps.vars.outputs.reporting_server }} || true
          
          # Copy artifacts to reporting server
          echo "Copying artifacts to reporting server..."
          scp -i /home/ubuntu/build_cred/build \
              -o StrictHostKeyChecking=no \
              innotas-common.deb innotas-reporting.deb \
              build@${{ steps.vars.outputs.reporting_server }}:/tmp/
          
          if [ $? -ne 0 ]; then
            echo "Failed to copy artifacts to reporting server"
            exit 1
          fi
          
          # Install packages on reporting server
          echo "Installing packages on reporting server..."
          ssh -i /home/ubuntu/build_cred/build \
              -o StrictHostKeyChecking=no \
              -l build \
              ${{ steps.vars.outputs.reporting_server }} \
              "set -o pipefail; cd /tmp; sudo dpkg -i innotas-common.deb innotas-reporting.deb"
          
          if [ $? -eq 0 ]; then
            echo "Reporting server deployment completed successfully"
          else
            echo "Reporting server deployment failed"
            exit 1
          fi

      - name: Verify Deployment
        run: |
          echo "Verifying deployment..."
          echo "============================================"
          echo "App Server: ${{ steps.vars.outputs.app_server }} - Deployment Successful"

      - name: Cleanup artifacts
        if: always()
        run: |
          echo "Cleaning up artifacts from working directory..."
          echo "Current directory: $(pwd)"
          echo "Files before cleanup:"
          ls -lh *.deb 2>/dev/null || echo "No .deb files found"
          
          # Remove all .deb files
          rm -f *.deb
          
          echo "Cleanup completed"
          echo "Files after cleanup:"
          ls -lh *.deb 2>/dev/null || echo "All .deb files removed successfully"
